module GCodeParse where


import Data.List as L
--import Data.Char as C
import Control.Monad (forM_)
import Data.Time (getCurrentTime, diffUTCTime)
import Numeric (showFFloat, readFloat)

{-
STEP 0: basic setup and try

-}


iS4GC = "/home/kushik/Kushik/TU Chemnitz/Thesis and Work github/lpbf/lpbf/G code files/gcode files/Impact Test Samples 4 03-12-2024 rate.gcode"
-- Impact test sample 4, G code file

-- copied from CliParse.hs
-- the argument function is assumed to 
-- take a string that was read from the input file 
-- and return a string that is to be written to the putput file

interactWith :: (String -> String) -> FilePath -> FilePath -> IO ()
interactWith function inputFile outputFile = do 
    startTime <- getCurrentTime
    putStrLn $ "Start time: " ++ show startTime
    inputData <- (readFile inputFile)
 
    let output = function inputData
    writeFile outputFile output

    endTime <- getCurrentTime
    putStrLn $ "End time: " ++ show endTime
    
    let duration = diffUTCTime endTime startTime
    putStrLn $ "Duration: " ++ show duration

-- copied from CliParse.hs
-- Expecting only \n in the .gcode file not \r\n
splitLines :: String -> [String]
splitLines [] = []	
splitLines cs = 
	let (pre,suf) = L.break isLineTerminator cs
	in pre : case suf of
		('\r':'\n':rest) -> splitLines rest
		('\r':rest) -> splitLines rest
		('\n':rest) -> splitLines rest
		_ -> []
	
isLineTerminator :: Char -> Bool
isLineTerminator c = c == '\r' || c == '\n'

-- copied from CliParse.hs and slightly modified for .gcode files
-- Expecting only \n in the .gcode file not \r\n
-- Opposite of splitLines for .cli files
unSplitLinesGC :: [String] -> String
unSplitLinesGC [] = []
unSplitLinesGC (x:xs) = x ++ "\n" ++ unSplitLinesGC xs



{-
STEP 1: Identify and separate geometry lines
-}

{-
; generated by PrusaSlicer 2.8.1+win64 on 2024-12-03 at 08:46:35 UTC

; ciao

; external perimeters extrusion width = 0.11mm
; perimeters extrusion width = 0.11mm
; infill extrusion width = 0.11mm
; solid infill extrusion width = 0.11mm
; top infill extrusion width = 0.10mm

M104 S200 T0 ; set temperature
M104 S200 T1 ; set temperature
;TYPE:Custom
M109 S200 T0 ; set temperature and wait for it to be reached
M109 S200 T1 ; set temperature and wait for it to be reached
G21 ; set units to millimeters
G90 ; use absolute coordinates
M82 ; use absolute distances for extrusion
G92 E0
T0
G92 E0
; Filament gcode
M107
;LAYER_CHANGE
;Z:0.05
;HEIGHT:0.05
G92 E0
G1 X73.759 Y10.787 F7800
G1 Z.05
;TYPE:Solid infill
;WIDTH:0.112582
G1 F1800
G1 X71.287 Y10.787 E.00178
G1 X71.287 Y10.889 E.00185
G1 X73.713 Y10.889 E.0036
G1 X73.713 Y10.991 E.00367
G1 X71.287 Y10.991 E.00542


It can be assumed that 
    G92 E0
    T0
    G92 E0
    ; Filament gcode
    M107 
these lines also belong to the first layer, 
but these lines can not be assumed to be an indication of layer change

So,

Each layer new layer starts at the command
    ;LAYER_CHANGE

But, there are some prefix lines to the first layer. namely the lines atfer:

the line:
    M82 ; use absolute distances for extrusion

This line is considered the last line of the header

Might need to change later if the header changes when something else is changed.


the line:
    ; objects_info = {"objects":[]}

is considered the first line of the footer
-}

-- STEP 1.1 Get the geometry lines only
splitGeometryLines :: [String] -> ([String],[String],[String])
splitGeometryLines [] = ([],[],[])
splitGeometryLines allGCLines = (headerLines, geometryLines, footerLines) where
    headerRestTuple = L.break (L.isPrefixOf "M82 ; use absolute distances for extrusion") allGCLines
    headerLines = case snd headerRestTuple of
        [] -> fst headerRestTuple
        xs -> (fst headerRestTuple) ++ [(L.head xs)]

    geometryFooterTuple = case snd headerRestTuple of 
        [] -> ([],[])
        xs -> L.break (L.isPrefixOf "; objects_info = {\"objects\":[]}") (L.tail xs)
    geometryLines = fst geometryFooterTuple
    footerLines = snd geometryFooterTuple

-- STEP 1.2. Put the geometry lines back together with the header and the footer lines
unSplitGeometryLines :: ([String],[String],[String]) -> [String]
unSplitGeometryLines (headerLines, geometryLines, footerLines) = headerLines ++ geometryLines ++ footerLines

-- Now check if this is working.
myCheckSplit :: FilePath -> IO ()
myCheckSplit inputFile = do
    startTime <- getCurrentTime
    putStrLn $ "Start time: " ++ show startTime

    inputString <- readFile inputFile
    let (headerLines, geometryLines, footerLines) = splitGeometryLines . splitLines $ inputString
    
    putStrLn "Header lines: \n"
    forM_ (L.take 5 headerLines) print
    putStrLn "...\n"
    forM_ (lastN' 5 headerLines) print

    putStrLn "Geometry Lines: \n"
    forM_ (L.take 5 geometryLines) print
    putStrLn "...\n"
    forM_ (lastN' 5 geometryLines) print

    putStrLn "Footer Lines: \n"
    forM_ (L.take 5 footerLines) print
    putStrLn "...\n"
    forM_ (lastN' 5 footerLines) print

    endTime <- getCurrentTime
    putStrLn $ "End time: " ++ show endTime
    
    let duration = diffUTCTime endTime startTime
    putStrLn $ "Duration: " ++ show duration

lastN' :: Int -> [a] -> [a]
lastN' n xs = L.foldl' (const . L.drop 1) xs (L.drop n xs)
